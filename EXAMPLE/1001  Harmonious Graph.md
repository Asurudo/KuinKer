# 1001  Harmonious Graph

**来源**： https://codeforces.com/contest/1253/problem/D 

$tag$ : `深度优先搜索` `并查集` `图论` `贪心` 



## 题目大意

给定一个有 $n(3≤n≤200000)$ 个点和 $m(1≤m≤200000)$ 条边的**无向图** 。对于一个无向图，当且仅当若任意编号为 $x$ 的点与编号为 $y$ 的点互相可达 $(x＜y)$，则存在路径对于任意编号为 $r(x＜r＜y)$ 的点使得 $x,r,y$ 互相可达时，该无向图被称为和谐图， 求至少增加多少条边可使给定的无向图成为和谐图。

## 题目样例

### 样例输入

```
14 8
1 2
2 7
3 4
6 3
5 7
3 8
6 8
11 12
```

### 样例输出

```
1
```

### 样例解释

给定的无向图并不和谐(比如，$1<6<7$，原图中 $1$ 可到达 $7$ ，但是 $1$ 无法到达 $6$ )。加入边 $(2,4)$ 即可让原图变为和谐图。

## 题目解法

对于图中每一个连通块，我们都可以找到其中编号最小的点 $l$ 与编号最大的点 $r$ ，我们将该连通块记作 $[l,r]$ 。

我们可以将 $[l,r]$ 看作一个区间，若两个区间相交 $(intersect)$ ,则两区间代表的连通块必须要手动连一条线使得这两个连通块变为一个连通块。

我们设变量 $st$ 和 $D$ 代表区间 $[st,D]$ 之间所有点都需要连通，因此可以遍历所有点，当当前点 $i$ 大于 $D$ 时，我们认为到达了一个新的区间，所以将 $st$ 设为 $i$ ,并深搜所有 $i$ 能到达的点，用并查集表示他们已经相连，并找出其中最大的点编号作为 $D$ 。接着向后遍历，若当前点 $j(i＜j＜D)$ 并没有与 $st(=i)$ 相连，则贪心地把 $st$ 所在集合和 $j$ 所在集合相连，且深搜 $j$ 将与其相连的所有点与 $st$ 相连，并用遇到的最大的点更新 $D$ 。

为什么要不断更新 $D$ 呢？因为将 $st$ 代表集合与 $j$ 代表集合相连，意味着将 $st$ 可达 $j$ 代表集合中所有点，自然也包括了 $j$ 代表集合中最大的点，我们记 $j$ 代表集合中最大的点为 $z$ 。若有 $z＞D$ 则 $[st,z]$ 中所有点都要连通，因此自然要更新 $D$,直到 $j＞D$ ，该区间才算结束。

为什么贪心正确呢？因为 $st$ 代表集合和 $j$ 代表集合现在是两个连通块，证明他们不连通，他们中的点自然不互相可达。但 $st$ 和 $j$ 两点一定要可达，所以只需要在这两个集合中各找一点连边即可，不妨找 $st$ 与 $j$ 连边。

时间复杂度 $O(nα(n)+m) ≈ O(nlogn+m)$  

## 核心代码

```c++
void dfs(int cur)
{
	//将当前点加入st代表集合内
    djs.unite(st,cur);
    //更新区间右端点D
	D = max(D,cur);
	vis[cur] = 1;
    //链式前向星遍历临边
	for(int i = g.head[cur]; i; i = g.Next[i])
	{
		int y = g.ver[i];
		if(!vis[y])
			dfs(y);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	_for(i,0,m)
	{
		int a, b;
		scanf("%d%d",&a,&b);
        //链式前向星连边，无向图注意两倍空间
		g.add(a,b);g.add(b,a);
	}
	int ans = 0;
    //遍历所有点
	_for(i,1,n+1)
	{
		//若st与i不在一个连通块内且i在[st,D]区间内
        if(i<D && !djs.same(st,i))
            //连边，更新D，更新st集合
			dfs(i),ans ++;
        //若当前点已不在[st,D]区间内，创建一个新的区间
		if(i>D)
		{
			st = i;dfs(i);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

