# 单源最短路径

## Dijkstra

### 例题编号

**NULL**

------

算法流程如下:

1. 初始化距离数组 $d[st]:=0$ ,其余节点的 $d$ 都设为 $+∞$ 。
2. 找出一个未使用过且 $d$ 最小的节点 $x$ ，然后使用它并标记。
3. 扫描 $x$ 所有出边 $(x,y,w)$ ，若 $d[y]>d[x]+w$，则更新 $d[y]:=d[x]+w$ 。
4. 重复步骤 $2,3$ 直到所有节点都被使用过。

因为全局最小值不可能再被其他节点更新，因此该贪心算法正确。

此算法只适用于边权值都为非负的情况，时间复杂度为 $O((m+n)logn)$ 。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define _for(i,a,b) for(register int i = (a);i < b;i ++)
#define _rep(i,a,b) for(register int i = (a);i > b;i --)
#define INF 0x3f3f3f3f3f3f3f3f
#define pb push_back
//最大点数
#define maxn 100003
//最大边数
#define maxe 200003
struct G
{
	int n,m;
	//存储某一条边的后一条边
	int Next[maxe];
	//存储边的起始信息，若有x ->(w) y，则head[x]为第一条到达边的编号
	int head[maxn];
	//存储边的到达信息 ，即 x ->(w) y中的y
	int ver[maxe];
	//存储边的权值信息 ，即 x ->(w) y中的w
	int val[maxe];
	//有向边的总数
	int tot;
	void add(int x,int y,int w)
	{
		ver[++tot] = y,Next[tot] = head[x],head[x] = tot,val[tot] = w;
	}
} g1;

struct Dij
{
	//first 是最短距离，second 是顶点编号
	typedef pair<int,int> P;
	//距离数组
	ll d[maxn];
	//是否使用过？
	int vis[maxn];
	priority_queue<P,vector<P>,greater<P>> q;
	// s -> other v
	int s;
	void dij(int s,const G &g)
	{
		//d初始化
		_for(i,1,g.n+1)
			d[i] = INF;
		d[s] = 0;
		//起点入队
		q.push(P {0,s});
		while(!q.empty())
		{
			//获取d最小的点
			P p = q.top();
			q.pop();
			int x = p.second;
			if(vis[x]) continue;
			vis[x] = 1;
			//使用x更新到其他点距离 
			for(int i = g.head[x]; i; i = g.Next[i])
			{
				int y = g.ver[i];
				int w = g.val[i];
				if(d[y] > d[x] + w)
				{
					d[y] = d[x] + w;
					q.push(P {d[y],y});
				}
			}
		}
	}
} d1;

int main()
{
	int s;
	scanf("%d%d%d",&g1.n,&g1.m,&s);
	_for(i,0,g1.m)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		g1.add(x,y,z);
	}
	d1.dij(s,g1);
	_for(i,1,g1.n+1)
		printf("%d ",d1.d[i]);
	return 0;
}
```

