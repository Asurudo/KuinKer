# 主席树

## 例题编号：

**无**

------

主席树是线段树的延申，是为了解决查询在区间 $[1,n]$ 上，对于每一次修改操作后，树分别都是什么样的，也就是他具有一定历史性，所以可持久，你可以任意访问在经历过的某一次修改后的树。

不过主席树只能对单点更新·区间查询的线段树进行历史记录，因为他的本质是对于一颗正常的线段树，不断从内存池中增设此次修改的一条链上的节点。

空间复杂度为 $O(n+mlogn)$ ，时间复杂度为 $O(mlogn)$ 。

代码给出的是查询区间第 $k$ 小值，详情见 $LYD$ $P.257$ 

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define _for(i,a,b) for(int i = (a);i < b;i ++)
#define _rep(i,a,b) for(int i = (a);i > b;i --)
#define INF 0x3f3f3f3f
#define pb push_back
#define lowbit(x) ((x)&(-x))
#define mod 1000000007
#define MIKU 39
#define maxn 300039

int tot, n;
ll a[maxn];
struct disp
{
	//离散化后大小
	int sz; 
	//acopy 为 a 排序去重以后 
	ll acopy[maxn];
	// lsh[i] 为 a[i] 离散化后的值 
	int lsh[maxn]; 
    //kn为原数组大小
	void init(int kn)
	{
		n = kn;
        //可以把此处数组a换成别的数组
        memcpy(acopy,a,sizeof(a));
		sort(acopy+1,acopy+1+n);
		sz = unique(acopy+1,acopy+1+n)-(acopy+1);
        //可以把此处数组a换成别的数组
		_for(i,1,n+1)
			lsh[i] = lower_bound(acopy+1,acopy+1+sz,a[i])-acopy;
	}
	//O(logn)
	int getsmall(ll x)
	{
		return lower_bound(acopy+1,acopy+1+sz,x)-acopy;
	}
	//O(1)
	ll getbig(int i)
	{
		return acopy[i];
	}
}dsp; 

struct XJPSegNode
{
	int lc, rc;
	ll max;
	int cnt;
#define lc(x) segpool[x].lc
#define rc(x) segpool[x].rc
#define MAX(x) segpool[x].max
#define cnt(x) segpool[x].cnt
}segpool[maxn*80];
struct XJPSegTree
{
	int root;
	void init(int a,int b)
	{
		root = build(a,b);
	}
	//O(nlogn)建议只对初始线段树使用 
	int build(int l,int r)
	{
		int p = ++tot;
		if(l==r)
		{
			MAX(p) = a[l];
			cnt(p) = 0;
			return p;
		}
		int mid = (l+r)/2;
		lc(p) = build(l,mid);
		rc(p) = build(mid+1,r);
		MAX(p) = max(MAX(lc(p)),MAX(rc(p)));
		cnt(p) = cnt(lc(p)) + cnt(rc(p));
		return p;
	}
	int change(int base,int l,int r,int x,ll d)
	{
		int p = ++tot;
		segpool[p] = segpool[base];
		if(l==r)
		{
			MAX(p) = d;
			cnt(p) += d;
			return p;
		}
		int mid = (l+r)/2;
		if(x <= mid)
			lc(p) = change(lc(base),l,mid,x,d);
		else
			rc(p) = change(rc(base),mid+1,r,x,d);
		MAX(p) = max(MAX(lc(p)),MAX(rc(p)));
		cnt(p) = cnt(lc(p)) + cnt(rc(p));
		return p;
	}
	int ask(int p, int q,int l,int r,int k)
	{
		if(l==r)
			return l;
		int mid = (l+r)/2;
		int lcnt = cnt(lc(p)) - cnt(lc(q));
		if(k<=lcnt)
			return ask(lc(p),lc(q),l,mid,k);
		else
			return ask(rc(p),rc(q),mid+1,r,k-lcnt);
	}
}XJPT[maxn];

int m; 
int main()
{
	scanf("%d%d",&n,&m);
	_for(i,1,n+1)
		scanf("%lld",&a[i]);
	dsp.init(n);
	XJPT[0].init(1,dsp.sz);	
	_for(i,1,n+1)
		XJPT[i].root = XJPT[i].change(XJPT[i-1].root,1,dsp.sz,dsp.getsmall(a[i]),1);
	_for(i,1,m+1)
	{
		int l, r, k;
		scanf("%d%d%d",&l,&r,&k);
		printf("%lld\n",dsp.getbig(XJPT[0].ask(XJPT[r].root,XJPT[l-1].root,1,dsp.sz,k)));
	}
	return 0;
}
```
