<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
# 二分查找

## 例题编号

**NULL** 

------

当一个问题的答案具有单调性，即当给出一个可能解 $x$ 的时候，通过判定函数 $f(x)$ 能确定当前可能解 $x$ 是否为可行解，若非可行解，因为答案具有单调性的缘故，则可以否定掉以当前可能解 $x$ 为界的左半或右半所有解，然后从另一半去寻找另一个可行解。

若对于 $n$ 次询问，普通查找方式的时间复杂度为 $O(n^2)$ 。而我们可以通过先排序（时间复杂度 $O(nlogn)$ ），然后对于每次询问都可以在时间复杂度$O(logn)$解决，总时间复杂度就为 $O(nlogn+nlogn)=O(nlogn)$。

二分的实现方法多种多样，但是其细节之处确实需要仔细考虑。对于整数域上的二分，需要注意中止边界、左右区间取舍时的开闭情况；对于实数域上的二分，需要注意精度问题。

## 整数集合上的二分

### 手写版本

保证答案处于闭区间 $[l,r]$ 之间，循环以 $l==r$ 结束

#### 第一种写法

```c++
/*
	答案在闭区间[l,r]之间
	在单调递增序列a中查找>=x的数中最小的一个(即x或x的后继) 
	启用r++语句后，若返回的是a[r+1]，则未找到解 
	如无特殊情况，不建议修改函数中任何内容！
*/
ll a[maxn];
ll Bsearch(int l,int r,ll x)
{
	r ++;
	while(l < r)
	{
		int mid = (l + r) >> 1;
		if(a[mid] >= x)
			r = mid;
		else
			l = mid + 1;
	}
	return a[l];
} 
```

#### 第二种写法

```c++
/*
	答案在闭区间[l,r]之间
	在单调递增序列a中查找<=x的数中最大的一个(即x或x的前驱) 
	启用l--语句后，若返回的是a[l-1]，则未找到解 
	如无特殊情况，不建议修改函数中任何内容！
*/
ll a[maxn];
ll Bsearch(int l,int r,ll x)
{
	l --;
	while(l < r)
	{
		int mid = (l + r + 1) >> 1;
		if(a[mid] <= x)
			l = mid;
		else
			r = mid - 1;
	}
	return a[l];
} 
```

### STL版本

$lower\_bound$ 的第三个参数传入一个元素 $x$ ,在两个迭代器(或指针)指定的部分上执行二分查找，返回指向第一个**大于等于** $x$ 的元素的位置的迭代器(或指针)。$upper\_bound$ 则查找第一个**大于** $x$  的元素。

```c++
//在有序数组(下标为1~n)中查找大于等于x的最小整数的下标
int i = lower_bound(a+1, a+n+1, x) - a;

//在有序vector<ll>中查找小于等于x的最大整数（假设一定存在）
ll y = *--upper_bound(a.begin(), a.end(), x);

//binary_search()，找到则返回1，没找到返回0
int b = binary_search(a+1, a+n+1, x)
```



## 实数域上的二分

注意需要明确精度 $eps$ 是多少即可。

```c++
//需要保留k位小数时,则取eps = 10^-(k+2) 
#define eps 1e-5
//k为正解 
double k = 39.99;
bool judge(double j)
{
	return j > k;
}
//解在 [l,r]之间 
double Bsearch(double l,double r)
{
	//若精度不容易确定或表示，可以采用循环固定次数的二分方法
    //for(int i = 0;i < 100;i ++)
    while(l + eps < r)
	{
		double mid = (l + r) / 2;
		if(judge(mid))
			r = mid;
		else
			l = mid;
	}
	return l;
}
```



## 二分答案转化为判定

将**整数集合上的解法**中的 $if()$ 内条件换为 $judge()$ 函数即可，注意仍然需要二选一。

若当前 $judge(mid)$ 的返回值表明最终结果只可能在左半边 且 $mid$ 仍有可能为最终结果，则使用 $(l + r) >> 1$ 版本

若当前 $judge(mid)$ 的返回值表明最终结果只可能在右半边 且 $mid$ 仍有可能为最终结果，则使用 $(l + r+1) >> 1$ 版本
