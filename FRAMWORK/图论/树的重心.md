# 树的重心

## 例题编号

**NULL**

------

对于一棵无根树中某一结点 $x$ ，若去除节点 $x$ 后，原树会形成一个森林，森林中树的结点的最大值称为该节点 $x$ 的重量。重量最小的结点即为该树的重心。

求树的重心，时间复杂度为 $O(n)$。

```c++
struct TreeCore
{
	//树的重心的点标号 
	int core;
	//树的重量 (最大子树大小)
	int ans;
	//以 x 为根的子树大小（含自身） 
	int size[maxn]; 
	int vis[maxn];
	//获取树的重心 
	int getcore(const G &g)
	{
		ans = 0; 
		dfs(g,1);
		return core;
	}
	void dfs(const G &g,int x)
	{
		vis[x] = 1;
		size[x] = 1;
		//删掉x以后分成的最大子树的大小 
		int maxpart = 0;
		
		for(int i = g.head[x]; i; i = g.Next[i])
		{
			int y = g.ver[i];
			if(vis[y])
				continue;
			dfs(g,y);
			size[x] += size[y];
			maxpart = max(maxpart,size[y]);
		} 
		maxpart = max(maxpart, g.n - size[x]);
		if(maxpart < ans)
		{
			ans = maxpart;
			core = x;
		}
	} 
} tc; 
```

